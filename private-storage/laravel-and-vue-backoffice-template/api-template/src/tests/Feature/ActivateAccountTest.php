<?php

namespace Tests\Feature;

use App\Interfaces\PasswordResetRepositoryInterface;
use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
use Tests\TestCase;

class ActivateAccountTest extends TestCase
{

    private PasswordResetRepositoryInterface $passwordResetRepository;
    private string $activateAccountUrl;

    private array $activateAccountRequest;

    private User $user;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->passwordResetRepository = resolve(PasswordResetRepositoryInterface::class);

        $this->activateAccountUrl = route('activate-account');

        $this->user = User::factory()->create(['is_active'=> false]);

        $this->activateAccountRequest = [
          'email'=> $this->user->email,
          'password'=> 'Bobasmrad2@',
          'password_confirmation' => 'Bobasmrad2@',
          'token'=> $this->generateForgotPasswordToken($this->user)
        ];


    }


    public function test_email_required_validation():void
    {
        $this->activateAccountRequest['email'] = '';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'email'=>'E-mail adresa je obavezna'
        ]);



        $this->activateAccountRequest['email'] = null;

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'email'=>'E-mail adresa je obavezna'
        ]);


        unset($this->activateAccountRequest['email']);

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'email'=>'E-mail adresa je obavezna'
        ]);
    }

    public function test_only_inactive_users_can_activate_account_validation():void
    {

        $this->user->update([
            'is_active'=> true
        ]);

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'email'=>'Uneta e-mail adresa ne postoji u našim rekordima'
        ]);
    }

    public function test_password_required_validation():void
    {
        $this->activateAccountRequest['password'] = '';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'password'=>'Morate uneti šifru'
        ]);



        $this->activateAccountRequest['password'] = null;

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'password'=>'Morate uneti šifru'
        ]);


        unset($this->activateAccountRequest['password']);

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'password'=>'Morate uneti šifru'
        ]);
    }

    public function test_password_min_validation():void
    {
        $this->activateAccountRequest['password'] = '1234567';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_have_at_least_one_digit_validation():void
    {
        $this->activateAccountRequest['password'] = 'ABCDASDASDA!a';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_have_at_least_one_letter_validation():void
    {
        $this->activateAccountRequest['password'] = '12345678@!';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_have_at_least_one_symbol_validation():void
    {
        $this->activateAccountRequest['password'] = 'Abcdeedfg123';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_be_confirmed_validation():void
    {
        $this->activateAccountRequest['password'] = 'SomeOtherPassword123@!';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_be_uncompromised_validation():void
    {
        $this->activateAccountRequest['password'] = 'Password1234!';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

    }


    public function test_account_activate_token_required_validation():void
    {
        $this->activateAccountRequest['token'] = '';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'token'=>'Molimo napravite novi zahtev za resetovanje šifre'
        ]);



        $this->activateAccountRequest['token'] = null;

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'token'=>'Molimo napravite novi zahtev za resetovanje šifre'
        ]);


        unset($this->activateAccountRequest['token']);

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'token'=>'Molimo napravite novi zahtev za resetovanje šifre'
        ]);
    }

    public function test_account_activate_token_valid_validation():void
    {
        $this->activateAccountRequest['token'] = 'notSameTokenAsDbToken';

        $response = $this->postJson(
            $this->activateAccountUrl,
            $this->activateAccountRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'token'=>'Molimo napravite novi zahtev za resetovanje šifre'
        ]);

    }

    public function test_user_can_activate_account(): void
    {

        $response = $this->postJson($this->activateAccountUrl, $this->activateAccountRequest);

        $response->assertOk();

        $response->assertJsonStructure([
            'message'
        ]);

        $response->assertJson([
            'message'=>  'Uspešno ste aktivirali nalog, možete se ulogovati putem izabrane šifre i Vaše e-mail adrese: '.$this->user->email
        ]);

        $this->user->refresh();

        $this->assertTrue(Hash::check($this->activateAccountRequest['password'], $this->user->password));
    }
    private function generateForgotPasswordToken(User $user): string{
        $newUserToken = Str::random(64);

        $this->passwordResetRepository->store($user->email, $newUserToken);

        return $newUserToken;
    }
}
