<?php

namespace Tests\Feature;

use App\Interfaces\PasswordResetRepositoryInterface;
use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
use Tests\TestCase;

class ResetPasswordTest extends TestCase
{

    private PasswordResetRepositoryInterface $passwordResetRepository;
    private string $resetPasswordUrl;

    private array $resetPasswordRequest;

    private User $user;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->passwordResetRepository = resolve(PasswordResetRepositoryInterface::class);

        $this->resetPasswordUrl = route('reset-password');

        $this->user = User::factory()->create();

        $password = 'Sifrasasd123!@#';

        $this->resetPasswordRequest = [
          'email' => $this->user->email,
          'password' => $password,
          'password_confirmation' => $password,
          'token'=> $this->generateResetPasswordToken($this->user)
        ];
    }


    public function test_email_required_validation():void
    {
        $this->resetPasswordRequest['email'] = '';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'email'=>'E-mail adresa je obavezna'
        ]);



        $this->resetPasswordRequest['email'] = null;

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'email'=>'E-mail adresa je obavezna'
        ]);


        unset($this->resetPasswordRequest['email']);

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'email'=>'E-mail adresa je obavezna'
        ]);
    }

    public function test_only_active_users_can_reset_password_validation():void
    {

        $this->user->update([
            'is_active'=> false
        ]);

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'email'=>'Uneta e-mail adresa ne postoji u našim rekordima'
        ]);
    }

    public function test_password_required_validation():void
    {
        $this->resetPasswordRequest['password'] = '';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'password'=>'Morate uneti šifru'
        ]);



        $this->resetPasswordRequest['password'] = null;

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'password'=>'Morate uneti šifru'
        ]);


        unset($this->resetPasswordRequest['password']);

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'password'=>'Morate uneti šifru'
        ]);
    }

    public function test_password_min_validation():void
    {
        $this->resetPasswordRequest['password'] = '1234567';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_have_at_least_one_digit_validation():void
    {
        $this->resetPasswordRequest['password'] = 'ABCDASDASDA!a';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_have_at_least_one_letter_validation():void
    {
        $this->resetPasswordRequest['password'] = '12345678@!';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_have_at_least_one_symbol_validation():void
    {
        $this->resetPasswordRequest['password'] = 'Abcdeedfg123';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_be_confirmed_validation():void
    {
        $this->resetPasswordRequest['password'] = 'SomeOtherPassword123@!';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

    }

    public function test_password_must_be_uncompromised_validation():void
    {
        $this->resetPasswordRequest['password'] = 'Password1234!';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

    }


    public function test_password_reset_token_required_validation():void
    {
        $this->resetPasswordRequest['token'] = '';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'token'=>'Molimo napravite novi zahtev za resetovanje šifre'
        ]);



        $this->resetPasswordRequest['token'] = null;

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'token'=>'Molimo napravite novi zahtev za resetovanje šifre'
        ]);


        unset($this->resetPasswordRequest['token']);

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'token'=>'Molimo napravite novi zahtev za resetovanje šifre'
        ]);
    }

    public function test_password_reset_token_valid_validation():void
    {
        $this->resetPasswordRequest['token'] = 'notSameTokenAsDbToken';

        $response = $this->postJson(
            $this->resetPasswordUrl,
            $this->resetPasswordRequest
        );

        $response->assertUnprocessable();

        $response->assertInvalid([
            'token'=>'Molimo napravite novi zahtev za resetovanje šifre'
        ]);

    }


    public function test_user_can_reset_password(): void
    {

        $response = $this->postJson($this->resetPasswordUrl, $this->resetPasswordRequest);

        $response->assertOk();

        $response->assertJsonStructure([
           'message'
        ]);

        $response->assertJson([
            'message'=> 'Šifra uspešno resetovana, možete se ulogovati putem novogenerisane šifre i Vaše e-mail adrese: '.$this->resetPasswordRequest['email']
        ]);

        $this->user->refresh();

        $this->assertTrue(Hash::check($this->resetPasswordRequest['password'], $this->user->password));
    }

    private function generateResetPasswordToken(User $user): string{
        $newUserToken = Str::random(64);
        $this->passwordResetRepository->store($user->email, $newUserToken);

        return $newUserToken;
    }
}
